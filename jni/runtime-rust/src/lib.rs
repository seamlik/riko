//! Runtime for wrapper code generated by Riko - JNI target.

pub mod object;

use bson::Bson;
use bson::Document;
use jni::sys::jbyteArray;
use jni::JNIEnv;
use riko_runtime::Marshal;

const ROOT_KEY_OF_ARGUMENT_DOCUMENT: &str = "value";

/// Marshals to JNI.
pub fn marshal<T>(data: &T, env: &JNIEnv) -> jbyteArray
where
    T: Marshal,
{
    let mut buffer = Vec::<u8>::new();
    bson::to_bson(data)
        .expect("Failed to encode the object as BSON")
        .as_document()
        .expect("The BSON is supposed to be a document")
        .to_writer(&mut buffer)
        .expect("Failed to write to the buffer");
    env.byte_array_from_slice(&buffer)
        .expect("Failed to send the marshaled data to JNI")
}

/// Unmarshals from JNI.
pub fn unmarshal<T>(env: &::jni::JNIEnv, src: ::jni::sys::jbyteArray) -> T
where
    T: Marshal,
{
    let input = env
        .convert_byte_array(src)
        .expect("Failed to receive a byte array from JNI");
    let document = if input.is_empty() {
        Default::default()
    } else {
        Document::from_reader(&mut input.as_slice()).expect("Failed to parse the data as BSON")
    };
    let entry = document
        .into_iter()
        .find(|(key, _)| key == ROOT_KEY_OF_ARGUMENT_DOCUMENT);
    if let Some((_, value)) = entry {
        bson::from_bson(value)
    } else {
        bson::from_bson(Bson::Null)
    }
    .expect("Type mismatch")
}
